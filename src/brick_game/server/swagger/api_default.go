/*
 * BrickGame
 *
 * BrickGame 3.0 REST API
 *
 * API version: 1.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

// #include "../../../common/header.h"
import "C"

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"time"

	wrap "server/wrapper"

	"github.com/gorilla/mux"
)

var controller *wrap.GameController
var gameInfo wrap.GameInfo
var gameType int
var prevButt int
var step int

type PageVariables struct {
	GameName string
}

func ActionsPost(w http.ResponseWriter, r *http.Request) {

	var actionRequest struct {
		Action string `json:"action"`
	}

	err := json.NewDecoder(r.Body).Decode(&actionRequest)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	var actionCode int
	var shouldRedirect bool

	log.Println("ACTION", actionRequest.Action, "ACTION")
	switch actionRequest.Action {
	case "up":
		actionCode = C.Up
	case "down":
		actionCode = C.Down
	case "left":
		actionCode = C.Left
	case "right":
		actionCode = C.Right
	case "enter":
		actionCode = C.Start
	case "action":
		actionCode = C.Action
	case "pause":
		actionCode = C.Pause
	case "terminate": // нажатие q
		actionCode = C.Terminate
		shouldRedirect = true
	case "exit": // нажатие e
		actionCode = C.Exit_game
		shouldRedirect = true
	default:
		http.Error(w, "Invalid action", http.StatusBadRequest)
		return
	}

	log.Println("ACTION NOW:", actionCode, "ACTION BEFORE:", prevButt)

	// Обновляем действие пользователя
	if actionCode == prevButt {
		log.Println("HOLD IS ON")
		controller.UpdateUserAction(actionCode, true)
	} else {
		log.Println("HOLD IS OFF")
		controller.UpdateUserAction(actionCode, false)
	}
	prevButt = actionCode
	controller.GetUserInput()

	// Деструктор контроллера при выходе
	if shouldRedirect {
		// Освобождаем ресурсы контроллера
		// controller.Destroy()

		// Отправляем редирект на фронтенд
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(map[string]string{
			"status": "redirect",
			"url":    "/api/games",
		})
		return
	}

	// Стандартный ответ для других действий
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(map[string]string{"status": "success"})
}

func GamesGameIdPost(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	gameId := vars["gameId"]

	w.Header().Set("Content-Type", "text/html; charset=UTF-8")
	w.Header().Set("X-Content-Type-Options", "nosniff")
	gameData := struct {
		GameID   string
		GameName string
	}{
		GameID:   gameId,
		GameName: "", // Изначально пустое название игры
	}
	switch gameId {
	case "0":
		gameData.GameName = "Tetris"
		gameType, _ = strconv.Atoi(gameId)
		controller = wrap.NewGameController(0)
	case "1":
		gameData.GameName = "Snake"
		gameType, _ = strconv.Atoi(gameId)
		controller = wrap.NewGameController(1)
	case "2":
		gameData.GameName = "Race" // Пример для третьей игры
		gameType, _ = strconv.Atoi(gameId)
		controller = wrap.NewGameController(2)
	default:
		gameData.GameName = "Unknown Game" // Название по умолчанию
	}
	tmpl := templates.Lookup("index.html")
	// Рендеринг с полной обработкой ошибок
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, gameData); err != nil {
		log.Printf("[ERROR] Template execution error: %v", err)
		http.Error(w, "Template rendering error", http.StatusInternalServerError)
		return
	}
	createField()
	// Запись результата
	w.WriteHeader(http.StatusOK)
	if _, err := w.Write(buf.Bytes()); err != nil {
		log.Printf("[ERROR] Writing response error: %v", err)
	}
}

func GamesGet(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/html; charset=UTF-8")

	err := templates.ExecuteTemplate(w, "menu.html", r)
	if err != nil {
		log.Printf("Template error: %v", err)
		http.Error(w, "Template error", http.StatusInternalServerError)
		return
	}
}

func createField() {
	gameInfo.Field = make([][]int, 20)
	gameInfo.Next = make([][]int, 5)
	for y := 0; y < 20; y++ {
		gameInfo.Field[y] = make([]int, 10)
	}
	for y := 0; y < 5; y++ {
		gameInfo.Next[y] = make([]int, 5)
	}
}

func StateGet(w http.ResponseWriter, r *http.Request) {
	// Расширенное логирование
	log.Printf("StateGet FULL REQUEST DETAILS:")
	log.Printf("Method: %s", r.Method)
	log.Printf("URL: %s", r.URL.String())
	log.Printf("Headers: %+v", r.Header)

	// Принудительная установка заголовков
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.Header().Set("X-Debug", "StateGet Handler")

	// time.Sleep(time.Second)
	if step > gameInfo.Speed {
		step = 0
		controller.MakeStep()
	}
	step++
	// controller.UpdateUserAction(9, false)
	// controller.GetUserInput()
	controller.UpdateState()
	gameInfo = controller.GetGameInfo(&gameInfo, gameType)
	w.WriteHeader(http.StatusOK)
	encoder := json.NewEncoder(w)
	encoder.SetIndent("", "  ")

	if err := encoder.Encode(gameInfo); err != nil {
		log.Printf("CRITICAL JSON ENCODING ERROR: %v", err)
		http.Error(w, fmt.Sprintf("Encoding error: %v", err), http.StatusInternalServerError)
		return
	}

	log.Println("StateGet completed SUCCESSFULLY")
	log.Println(gameInfo)
}

// func convertGameInfoToGoState(cGameInfo *C.GameInfo_t) GameState {
// 	state := GameState{
// 		Field:     make([][]int, 20),
// 		Next:      make([][]int, 5),
// 		Score:     int(cGameInfo.score),
// 		HighScore: int(cGameInfo.high_score),
// 		Level:     int(cGameInfo.level),
// 		Speed:     int(cGameInfo.speed),
// 		Pause:     bool(cGameInfo.pause != 0),
// 	}
// 	// Проверяем границы

// 	// Получаем указатель на строку

// 	for y := 0; y < 20; y++ {
// 		rowPtr := *(**C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(cGameInfo.field)) + uintptr(C.int(y)*C.int(unsafe.Sizeof((*C.int)(nil))))))
// 		state.Field[y] = make([]int, 10)
// 		for x := 0; x < 10; x++ {
// 			// Предполагаем, что cGameInfo.field - это указатель на двумерный массив
// 			state.Field[y][x] = int(*(*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(rowPtr)) + uintptr(C.int(x)*C.int(unsafe.Sizeof(C.int(0)))))))
// 		}
// 	}

// 	return state
// }

func PlayGame(gameType wrap.GameName) {
	controller := wrap.NewGameController(gameType)
	controller.MakeStep()
	controller.UpdateUserAction(0, false)
	time.Sleep(time.Second)
}
